<!doctype html>
<html>
  <head>
    <!-- https://cdn.jsdelivr.net/npm -->
    <script src="./vue@3.4.26/dist/vue.global.min.js"></script>
    <script src="./rxjs@7.8.1/dist/bundles/rxjs.umd.min.js"></script>
    <script src="./@vueuse/rxjs@10.9.0/index.iife.js"></script>

    <link href="./splitpanes@3.1.5/dist/splitpanes.min.css" rel="stylesheet">
    <script src="./splitpanes@3.1.5/dist/splitpanes.umd.min.js"></script>

    <link href="./@xterm/xterm@5.5.0/css/xterm.min.css" rel="stylesheet"/>
    <script src="./@xterm/xterm@5.5.0/lib/xterm.min.js"></script>
    <script src="./@xterm/addon-fit@0.10.0/lib/addon-fit.min.js"></script>

    <script src="./@xterm/addon-fit@0.10.0/lib/addon-fit.min.js"></script>

    <style>
      html, body { height: 100%; box-sizing: border-box;  margin: 0; padding: 0; }
      #app{ height: 100%; box-sizing: border-box;  margin: 0; padding: 0; }
    </style>
    <link href="./component/context.css" rel="stylesheet"/>
  </head>
  <body>
    <!-------- view -------->
    <div id ="app">
      <vue-split-pane horizontal class="default-theme" style="width:100%; height:100%;" >
        <!-- canvas -->
        <vue-pane ref="testRef" style="overflow:scroll; position: relative; background-color: gray;">
          <canvas-ex 
            :margin="20"
            ref = "canvasRef"
            :zoom="zoom" @update:zoom="$event => (zoom = $event)"
            :select="selected" @update:select="$event => (selected = $event)"
            :rendering="rendering ? 'pixelated' : 'auto'"
            @on-drop="onDrop"
            @on-context="onContextmenu"
            @on-mousemove="onMousemove"
            @on-wheel="onWheel"
            ></canvas-ex>
        </vue-pane>
        <vue-pane style="width:100%; background-color: white;" v-if="termShow">
          <!-- terminal -->
          <my-terminal ref="termRef"
            :on-async-key="beforeOnKey"
            @on-change="onChange" 
            @on-submit="onSubmit" :on-async-submit="onAsyncSubmit"
          ></terminal>
        </vue-pane>
      </vue-split-pane>
      <!-- context-menu / mouse-stalker -->
      <mouse-stalker target="canvas" ref="stalkerRef" ></mouse-stalker>
      <context-menu ref="contextRef" :items="contextList"></context-menu>
    </div>
    <!-------- logic -------->
    <script type="module">
      import { 
        sleep, indoc,
        asyncCheckWebview, post, asyncGetTxt, asyncPostJson, asyncPostPng, asyncPostPixel, 
        setState,
        readFile
      } from "./js/lib.js"

      // await asyncCheckWebview();// undefined
      // setState({ a: "hoge" });
      // console.log(window.dummyState)

      import { wtermComponent, Wterm } from "./component/wterm.js"
      import { canvasEx } from "./component/canvas-ex.js"
      import { contextmenu } from "./component/context.js"
      import { stalker } from "./component/stalker.js"

      const { createApp, ref, nextTick, onMounted, reactive } = window.Vue;
      const { /* from */ /* fromEvent */ of, merge, partition,
        filter, first, delay, map, takeUntil, debounceTime, scan,
        bufferToggle, switchMap, mergeMap,  
        share, tap
      } = window.rxjs;
      const { from, fromEvent } = window.VueUse;

      const app = createApp({
        setup() {
          const [termShow, termRef] = [ref(false), ref(null)];
          const [canvasRef, contextRef, stalkerRef] = [ref(null), ref(null), ref(null)];
          const [testRef] = [ref(null)];

          const [params, zoom, selected, rendering] = [ref({ bitshift :0, color:0 }), ref(null), ref(null), ref(false)];
          const state = ref({
            path : "", 
            subpath: "data.raw"
          });

          /* to sk */
          from(zoom).subscribe(e => stalkerRef.value.intext('shift+ctrl+0', `zoom : ${e}`) )
          from(selected).subscribe(e => stalkerRef.value.intext('1', `(${e.left},${e.top})-(${e.right},${e.bottom})`) )
          
          from(params).subscribe(async e => {
            const image = await asyncPostPng(e)
            canvasRef.value.redraw(image);
          })

          /******** method ********/

          const _readfile = async (path) => {
            state.value.path = path;
            await readFile(path, state.value.subpath)
            params.value = { ...params.value }
            // const image = await asyncPostPng(params.value)
            // canvasRef.value.redraw(image);
            // window.wterm.inputln(`echo ${e.detail.payload}`);
          };

          /******** terminal ********/

          const beforeOnKey = async (e) => { return true; }
          const onChange = (e)=> { /* console.log(e) */ }

          // どちらを使うか。
          const onAsyncSubmit = async (e) => { return false; /* true : promptの自動表示 */ }
          const onSubmit = async (e)=> {
            console.log(e)
            switch(e.type){
              case 'getpixel':{
                const dst = await asyncPostPixel({x: Number(e.payload[0]), y:Number(e.payload[1])});
                termRef.value.write(`${JSON.stringify(dst)}`);
              } break;
              case 'echo':{ termRef.value.write(`${e.payload.join(' ')}`); } break;

              case 'sleep-js':{
                for (let step = 0; step < 5; step++) {
                  if(termRef.value){
                    termRef.value.write(`${step}`);
                  }else{
                    console.log(step)
                  }
                  await sleep(1000);
                }
              } break;
              case 'sleep-event':{
                post("sleep", { a : 1, b :2 });
              } return; // callbackで受けるのでtermRef.value.prompt()を投げない
              case 'sleep-async':{
                const dst = await asyncPostJson("sleep", ["1"] )
                termRef.value.write(`${JSON.stringify(dst)}`);
              } break;
              case 'test':{
                post("unknown", { a : 1, b : 2 });
              } return; // termRef.value.prompt();を投げない
              
              case 'js1':{
                let dst = eval(e.payload.join(' '))
                if(termRef.value){
                  termRef.value.write(`${e.payload.join(' ')} = ${dst}`);
                }else{
                  console.log(dst)
                } 
              } break;
              case 'py1':{
                const dst = await asyncPostJson("py1", e.payload.join(' ') )
                termRef.value.write(`${e.payload.join(' ')} = ${JSON.stringify(dst)}`);
              } break;
              case 'py-pst':{
                const dst = await asyncPostJson("py", { 
                  code: indoc(`
                    def main(args):
                      print('__name__ :', __name__)
                      print('args :', args)
                      print('dst :', Pixel.get(10, 10))
                      Pixel.set(10, 10, 255)
                      args["x"] = 10
                      return args
                  `), 
                  entry: "main",
                  args: JSON.stringify({ x:1, y:2 }) 
                } );
                termRef.value.write(`${JSON.stringify(dst)}`);
              } break;

              case 'py':{
                const code = await asyncGetTxt(`local/${e.payload[0]}`)
                termRef.value.write(`========code========\r\n`);
                termRef.value.write(`${code}\r\n`);
                termRef.value.write(`========result========\r\n`);
                const dst = await asyncPostJson("py", { 
                  code: code,
                  entry: "main",
                  args: JSON.stringify(JSON.parse(e.payload[1]))
                } );
                termRef.value.write(`${JSON.stringify(dst)}`);
              } break;
              case 'ps':{
                const dst = await asyncPostJson("ps", e.payload[0]);
                termRef.value.write(`${dst}`);
              } break;

              case 'state':{
                termRef.value.write(`params : ${JSON.stringify(params.value, undefined, 2).replaceAll('\n', '\r\n')}\r\n`);
                termRef.value.write(`state : ${JSON.stringify(state.value, undefined, 2).replaceAll('\n', '\r\n')}\r\n`);
              } break;
              case 'set':{
                state.value = { ...state.value, [e.payload[0]] : e.payload[1] }
              } break;

              case 'zoom':{ zoom.value = e.payload } break;
                // termRef.value.write(`zoom : ${e.payload}`);
                // canvasRef.value.zoom(e.payload)
              case 'select':{ } break;
              case 'bitshift':{ } break;

              case 'read': { await _readfile(e.payload[0]); } break;
              default:
                break;
            }
            termRef.value.prompt(); // 自分でprompt必要
          }
          
          if(window.chrome.webview){
            const termwrite$ = fromEvent(window.chrome.webview, 'write');
            termwrite$.subscribe((e) => { termRef.value.write(`${e.detail}`); });
            const termprompt$ = fromEvent(window.chrome.webview, 'prompt');
            termprompt$.subscribe(() => { termRef.value.prompt(); });
          }

          /******** canvas ********/
          const onMousemove = async (e, real, debounce)=> { 
            if(debounce) {
              const dst = await asyncPostPixel({ x: real.x, y:real.y });
              const toHex = (n) => '0x' + (('00000000' + n.toString(16).toUpperCase()).substr(-8));
              stalkerRef.value.intext('0', `${real.x} ${real.y}\r\n${dst.data}\r\n${toHex(dst.data)}`)
            } else {
              stalkerRef.value.intext('0', `${real.x} ${real.y}`)
            }
            // termRef.value.log(`${real.x} ${real.y} : ${JSON.stringify(dst)}`)
            e.preventDefault()
          }

          const onDrop = async (e)=> {
            console.log('newWindowReq', e);
            switch(e.detail.type){
              case 'file': { await _readfile(e.detail.payload); } break;
              case 'http': { } break;
              default: break;
            }
          }

          /* wheel event */
          const onWheel = async (e) =>{
            const dst = e.deltaY > 0 ? -1 : 1
            params.value = {...params.value, bitshift : params.value.bitshift + dst }
            stalkerRef.value.intext('shift+0', `bitshift : ${params.value.bitshift}`)
          }

          /******** view ********/
          // const isBusy$ = from(busy);
          // isBusy$.subscribe(e =>{ document.body.style.cursor = e ? 'wait' : 'auto'; })

          /******** key event / shortcut ********/

          const keydown$ = fromEvent(document, 'keydown').pipe(filter( n => n.repeat === false ));
          // filter(n => n.code.startsWith('Key') && (n.altKey || n.ctrlKey || n.shiftKey) )
          keydown$.pipe(filter(n => 
            n.key.startsWith('Arrow')
            || ['\\', '.'].includes(n.key)
            || (!["Shift", "Control", "Alt"].includes(n.key) && (n.altKey || n.ctrlKey || n.shiftKey))
          )).subscribe( async e => {
            const keys = `${e.shiftKey ? 'shift+' : ''}${e.ctrlKey? 'ctrl+' : ''}${e.altKey? 'alt+' : ''}${e.code}`;
            console.log(keys)
            switch(keys){
              case 'shift+ArrowUp': { params.value = { ...params.value , bitshift: params.value.bitshift + 1 }; e.preventDefault(); } break;
              case 'shift+ArrowDown': { params.value = { ...params.value , bitshift: params.value.bitshift - 1 }; e.preventDefault(); } break;
              case 'shift+ArrowRight': { params.value = { ...params.value , color: params.value.color + 1 }; e.preventDefault(); } break;
              case 'shift+ArrowLeft': { params.value = { ...params.value , color: params.value.color - 1 }; e.preventDefault(); } break;

              case 'shift+ctrl+Semicolon': { zoom.value = zoom.value+1; e.preventDefault(); } break;
              case 'shift+ctrl+Minus': { zoom.value = zoom.value-1; e.preventDefault(); } break;

              case 'shift+ctrl+Semicolon': { zoom.value = zoom.value+1; e.preventDefault(); } break;
              case 'shift+ctrl+Minus': { zoom.value = zoom.value-1; e.preventDefault(); } break;

              case 'IntlRo': { rendering.value = !rendering.value } break;
              case '.': { 
                // const dst = await Wuzei.fetchJson({ type : "get_state" });
                // console.log(dst);
              } break;

              case "shift+ctrl+BracketLeft": termShow.value = !termShow.value; break;

              // コマンド送信テスト
              case "alt+KeyZ": { termRef.value.input_insert("___") } break;
              case "alt+KeyX": { termRef.value.input_append("___") } break;
              case "alt+KeyC": { 
                if(termRef.value){
                  termRef.value.input_overwrite("sleep") /* 隠してるときはコマンド何処から送るの？ */
                }else{
                  await onSubmit({ type: "sleep" })
                }
              } break;
              // ログテスト
              case "alt+KeyV":
                console.log(termRef.value)
                if(termRef.value){
                  termRef.value.log("logout")
                }else{
                  await onSubmit({ type: "sleep" })
                }
              default: {} break;
            }
          });

          /******** mouse event without zoom ********/

          /******** contextmenu ********/
          const onContextmenu = (e, n) => {
            if(n.inSelected){
              contextRef.value.show(e.clientX, e.clientY, 'IN')
            }else{
              contextRef.value.show(e.clientX, e.clientY, 'OUT')
            }
            e.preventDefault();
          }
          const contextList = reactive({
            "IN" : [
              { type : 'div', value: 'Clip Selected Image', action: (e)=>{ canvasRef.value.clip(true) } },
              { type : 'div', value: 'Clip Selected Coord', action: (e)=>{ navigator.clipboard.writeText(JSON.stringify(canvasRef.value.getSelect())); } },
              { type : 'div', value: 'Send Terminal', action: (e)=>{ 
                termRef.value.input_append(`py scripts/read.py '${JSON.stringify(selected.value)}'`) } },
            ],
            "OUT" : [
              { type : 'div', value: 'Copy Full', action: (e)=>{ canvasRef.value.clip(false) } },
              { type : 'hr' }, 
              { type : 'div', value: 'Dummy', action: (e)=>{ console.log('Dummy', e) } },
              { type : 'div', value: 'call py subprocess' },
              { type : 'div', value: 'call rust subprocess' },
            ]
          });

          /******** other event ********/
          if(window.chrome.webview){

            const updated$ = fromEvent(window.chrome.webview, 'updated');
            updated$.subscribe(async (e) => { console.log('updated', e); });

            const namedPipe$ = fromEvent(window.chrome.webview, 'namedPipe');
            namedPipe$.subscribe(e => { console.log("namedPipe", e) });

          }
          
          /******** onMounted ********/
          onMounted(async () => {
            console.log('app mounted')
            termShow.value = true;

            const image = await asyncPostPng({ bitshift: 0, color: 0 })
            canvasRef.value.redraw(image);

            nextTick(() => { console.log('app rendered'); });
          });
          return { 
            termShow, contextList, 
            onMousemove, onContextmenu, onDrop, onWheel,
            canvasRef, contextRef, stalkerRef,
            termRef, beforeOnKey, onChange, onSubmit, onAsyncSubmit,
            zoom, selected, rendering,
            testRef
          }
        }
      });
      app.component('vue-pane', window.splitpanes.Pane);
      app.component('vue-split-pane', window.splitpanes.Splitpanes);

      app.component('context-menu', contextmenu);
      app.component('mouse-stalker', stalker);
      app.component('canvas-ex', canvasEx);
      app.component('my-terminal', wtermComponent);
      app.mount('#app');
    </script>
  </body>
</html>

<!-- 


  
 -->