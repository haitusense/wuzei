<!doctype html>
<html>
  <head>
    <script src="./vue@3.4.26/dist/vue.global.min.js"></script>
    <script src="./rxjs@7.8.1/dist/bundles/rxjs.umd.min.js"></script>
    <script src="./@vueuse/rxjs@10.9.0/index.iife.js"></script>

    <link href="./splitpanes@3.1.5/dist/splitpanes.min.css" rel="stylesheet">
    <script src="./splitpanes@3.1.5/dist/splitpanes.umd.min.js"></script>

    <link href="./@xterm/xterm@5.5.0/css/xterm.min.css" rel="stylesheet"/>
    <script src="./@xterm/xterm@5.5.0/lib/xterm.min.js"></script>
    <script src="./@xterm/addon-fit@0.10.0/lib/addon-fit.min.js"></script>

    <style>
      html, body { height: 100%; box-sizing: border-box;  margin: 0; padding: 0; }
      #app{ height: 100%; box-sizing: border-box;  margin: 0; padding: 0; }
    </style>
  </head>
  <body>
    <!-------- view -------->
    <div id ="app">
      <vue-split-pane horizontal class="default-theme" style="width:100%; height:100%;" >
        <vue-pane style="overflow:scroll; position: relative;">
          <div>test</div>
        </vue-pane>
        <vue-pane style="width:100%; background-color: white;" v-if="termShow">
          <!-- terminal -->
          <my-terminal ref="termRef"
            :pty="pty"
            :before-on-key="(e) =>{ return true; }"
            @on-mounted="onTermMounted"
            @on-change="(e)=>{/*console.log(e)*/}"
          ></terminal>
        </vue-pane>
      </vue-split-pane>
    </div>
    <!-------- logic -------->
    <script type="module">
      import { 
        sleep, indoc,
        asyncCheckWebview, post, asyncGetTxt, asyncPostJson,
        readFile
      } from "./js/lib.js"
      import { wtermComponent, WPty } from "./component/wterm.js"
      const { createApp, ref, nextTick, onMounted, reactive } = window.Vue;
      const { /* from */ /* fromEvent */ of, merge, partition,
        filter, first, delay, map, takeUntil, debounceTime, scan,
        bufferToggle, switchMap, mergeMap,  
        share, tap
      } = window.rxjs;
      const { from, fromEvent } = window.VueUse;

      const app = createApp({
        setup() {
          const wv = window.chrome.webview;
          const pty = new WPty("wv");
          const isBusy = ref(true);
          const [termShow, bodyRef, termRef] = [ref(false), ref(null), ref(null)];

          const state = ref({
            path : "",
          });

          /******** method ********/

          /******** busy ********/
          from(isBusy).subscribe(e => { document.body.style.cursor = e ? 'wait' : 'auto'; })

          /******** event test ********/
          // fromEvent(document, 'action').subscribe(async e=>{ console.log("action event", e) });

          /******** action ********/
          pty.setCmd({
            /* js */
            'echo' : { 'note': 'function', 'func': async (e, callback) =>{
              callback(`echo overwrite`);
            }},
            'sleep' : { 'note': 'function', 'func': async (e, callback) =>{
              for (let step = 0; step < 5; step++) {
                callback(`${step}`);
                await sleep(1000);
              }
            }},

            'state' : { 'note': 'function', 'func': async (e, callback) =>{
              callback(`state : ${JSON.stringify(state.value, undefined, 2).replaceAll('\n', '\r\n')}\r\n`);
            }},
            'set' : { 'note': 'function', 'func': async (e, callback) =>{
              state.value = { ...state.value, [e.payload[0]] : e.payload[1] }
            }},

            /* rust */
            'env' : { 'note': 'function', 'func': async (e, callback) =>{
              const dst = await asyncPostJson("env", undefined )
              callback(JSON.stringify(dst));
            }},
            'cd' : { 'note': 'function', 'func': async (e, callback) =>{
              const dst = await asyncPostJson("cd", e.payload[0] )
              callback(JSON.stringify(dst));
            }},

            'ps' : { 'note': 'function', 'func': async (e, callback) =>{
              const dst = await asyncPostJson("ps", e.payload);
              callback(JSON.stringify(dst));
            }},
          
            'selenium' : { 'note': 'function', 'func': async (e, callback) =>{
                const code = await asyncGetTxt(`local/scripts/selenium.py`)
                callback(`\x1b[32m`);
                callback(`\x1b[32m========code========\r\n`);
                callback(`${code}\r\n`);
                callback(`\x1b[39m`);
                callback(`========result========\r\n`);
                const dst = await asyncPostJson("py", {
                  code: code,
                  entry: "main",
                  args: JSON.stringify({ url : e.payload[0] })
                } );
                callback(JSON.stringify(dst));
              }},
          });

          /******** terminal ********/

          const onTermMounted = async (e) => {
            console.log('onTermMounted');
            /* 自分でprompt必要 */
            pty.prompt(((await asyncPostJson("env", undefined))?.payload.current_dir ?? "offline") + "> ");
          }
          pty.onSubmit(async (e)=> {
            console.log("submit", e)
            isBusy.value = true;

            await pty.asyncCmd(e);

            /* 自分でprompt必要 */
            pty.prompt(((await asyncPostJson("env", undefined))?.payload.current_dir ?? "offline") + "> ");
            isBusy.value = false;
          });
          /*
            const onSubmit = async (e) => { }
            だとtermがないときにコマンドの行き先がなくなる
            termRef.valueで分岐させるのも煩雑だしlogが残らなくなるのでいまいち
          */
          
          if(wv){
            fromEvent(wv, 'write').subscribe((e) => { pty.write(`${e.detail}`); });
            fromEvent(wv, 'prompt').subscribe(async () => { 
              pty.prompt(((await asyncPostJson("env", undefined))?.payload.current_dir ?? "offline") + "> ");
            });
          }

          /******** key event / shortcut ********/

          const keydown$ = fromEvent(document, 'keydown').pipe(filter( n => n.repeat === false ));
          // filter(n => n.code.startsWith('Key') && (n.altKey || n.ctrlKey || n.shiftKey) )
          keydown$.pipe(filter(n => 
            n.key.startsWith('Arrow') || ['\\', '.'].includes(n.key)
            || (!["Shift", "Control", "Alt"].includes(n.key) && (n.altKey || n.ctrlKey || n.shiftKey))
          )).subscribe( async e => {
            const keys = `${e.shiftKey ? 'shift+' : ''}${e.ctrlKey? 'ctrl+' : ''}${e.altKey? 'alt+' : ''}${e.code}`;
            switch(keys){
              case "shift+ctrl+BracketLeft": { termShow.value = !termShow.value; }break;
              case "shift+ctrl+KeyZ": { pty.overwrite("echo hoge"); } break;
              case "shift+ctrl+KeyA": { pty.log("testwrite\r\n"); } break;
              case "shift+ctrl+KeyX": { pty.hideprompt(); } break;
              case "shift+ctrl+KeyC": { pty.showprompt(); } break;
              default: {} return;
            }
            e.preventDefault();
          });
          /******** other event ********/
          if(wv){

            const updated$ = fromEvent(wv, 'updated');
            updated$.subscribe(async (e) => { console.log('updated', e); });

            const newWindowReq$ = fromEvent(wv, 'newWindowReq');
            newWindowReq$.subscribe((e) => { 
              console.log('newWindowReq', e);
              switch(e.detail.type){
                case 'file': { } break;
                case 'http': { 
                  pty.overwrite(`selenium ${JSON.stringify(e.detail.payload)}`)
                } break;
                default: break;
              }
              
            });

            const namedPipe$ = fromEvent(wv, 'namedPipe');
            namedPipe$.subscribe(e => { console.log("namedPipe", e) });
          }
          
          /******** onMounted ********/
          onMounted(async () => {
            console.log('app mounted')
            termShow.value = true;
            isBusy.value = false;
            nextTick(() => { console.log('app rendered'); });
          });
          return { 
            isBusy,
            termShow, bodyRef,
            termRef, onTermMounted, pty
          }
        }
      });
      app.component('vue-pane', window.splitpanes.Pane);
      app.component('vue-split-pane', window.splitpanes.Splitpanes);
      app.component('my-terminal', wtermComponent);
      app.mount('#app');
    </script>
  </body>
</html>
