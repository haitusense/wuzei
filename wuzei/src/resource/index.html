<!doctype html>
<html>
  <head>
    <!-- https://cdn.jsdelivr.net/npm -->
    <!-- http://wuzei.localhost/resource/ -->
    <script src="./vue@3.4.26/dist/vue.global.min.js"></script>
    <script src="./rxjs@7.8.1/dist/bundles/rxjs.umd.min.js"></script>
    <script src="./@vueuse/rxjs@10.9.0/index.iife.js"></script>

    <link href="./splitpanes@3.1.5/dist/splitpanes.min.css" rel="stylesheet">
    <script src="./splitpanes@3.1.5/dist/splitpanes.umd.min.js"></script>

    <link href="./@xterm/xterm@5.5.0/css/xterm.min.css" rel="stylesheet"/>
    <script src="./@xterm/xterm@5.5.0/lib/xterm.min.js"></script>
    <script src="./@xterm/addon-fit@0.10.0/lib/addon-fit.min.js"></script>

    <style>
      html, body { height: 100%; box-sizing: border-box;  margin: 0; padding: 0; }
      #app{ height: 100%; box-sizing: border-box;  margin: 0; padding: 0; }
    </style>
  </head>
  <body>
    <!-------- view -------->
    <div id ="app">
      <vue-split-pane horizontal class="default-theme" style="width:100%; height:100%;" >
        <vue-pane style="overflow:scroll; position: relative;">
          <div>test</div>
          <div contenteditable virtualkeyboardpolicy="manual" id="editor"></div>
          <button id="edit-button">Edit</button>
        </vue-pane>
        <vue-pane style="width:100%; background-color: white;" v-if="termShow">
          <!-- terminal -->
          <my-terminal ref="termRef"
            :pty="pty"
            :before-on-key="(e) =>{ return true; }"
            @on-mounted="onTermMounted"
            @on-change="(e)=>{/*console.log(e)*/}"
            @on-drop="(e)=>{ onDrop = e}"
          ></terminal>
        </vue-pane>
      </vue-split-pane>
    </div>
    <!-------- logic -------->
    <script type="module">
      //@ts-check

      //@ts-ignore
      const [ wv, Vue, rxjs, VueUse ] = [ window.chrome.webview, window.Vue, window.rxjs, window.VueUse ];
      //@ts-ignore
      const [ Pane, Splitpanes ] = [ window.splitpanes.Pane, window.splitpanes.Splitpanes ];

      import { indoc, post, asyncGetTxt, asyncPostJson, readFile } from "./js/lib.js"
      import { wtermComponent, WPty } from "./component/wterm.js"
      const { createApp, ref, nextTick, onMounted, reactive } = Vue;
      const { /* from */ /* fromEvent */ of, merge, partition,
        filter, first, delay, map, takeUntil, debounceTime, scan,
        bufferToggle, switchMap, mergeMap,  
        share, tap

      } = rxjs;
      const { from, fromEvent } = VueUse;

      const pty = new WPty("wv");

      const app = createApp({
        setup() {
          const isBusy = ref(true);
          const [termShow, termRef] = [ref(false), ref(null)];
          const onDrop = ref(false);

          const state = ref({
            path : "",
          });

          /******** busy ********/
          from(isBusy).subscribe(e => { document.body.style.cursor = e ? 'wait' : 'auto'; })

          /******** event test ********/
          // fromEvent(document, 'action').subscribe(async e=>{ console.log("action event", e) });

          /******** action ********/
          pty.setCmd({
            /* js */
            'echo' : { 'type': 'action', 'func': async (e, callback) =>{
              callback(`echo overwrite: ${e.payload.join(' ')}`);
            }},

            'state' : { 'type': 'action', 'func': async (e, callback) =>{
              callback(`state : ${JSON.stringify(state.value, undefined, 2).replace(/\n/g, '\r\n')}\r\n`);
            }},
            'set' : { 'type': 'action', 'func': async (e, callback) =>{
              state.value = { ...state.value, [e.payload[0]] : e.payload[1] }
            }},

            /* rust */
            'env' : { 'type': 'function', 'func': async (e, callback) =>{
              const dst = await asyncPostJson("env", undefined )
              callback(JSON.stringify(dst));
            }},
            'cd' : { 'type': 'function', 'func': async (e, callback) =>{
              const dst = await asyncPostJson("cd", e.payload[0] )
              callback(JSON.stringify(dst));
            }},
            'ps' : { 'type': 'function', 'func': async (e, callback) =>{
              const dst = await asyncPostJson("ps", e.payload);
              callback(JSON.stringify(dst));
            }},
            'sleep-event' : { 'type': 'function', 'func': async (e, callback) =>{
              post("sleep", { a : 1, b :2 });
              // callbackで受けるのでtermRef.value.prompt()を投げない
              // event -> prompt
            }}, 
            'sleep-async' : { 'type': 'function', 'func': async (e, callback) => {
              const dst = await asyncPostJson("sleep", ["1"] )
              callback(JSON.stringify(dst));
            }},

            'selenium' : { 'type': 'script', 'func': async (e, callback) =>{
                const code = await asyncGetTxt(`local/scripts/selenium.py`)
                callback(`\x1b[32m`);
                callback(`\x1b[32m========code========\r\n`);
                callback(`${code}\r\n`);
                callback(`\x1b[39m`);
                callback(`========result========\r\n`);
                const dst = await asyncPostJson("py", {
                  code: code,
                  entry: "main",
                  args: JSON.stringify({ url : e.payload[0] })
                } );
                callback(JSON.stringify(dst));
              }},
          });

          /******** terminal ********/
          const customPrompt = async () => pty.prompt(((await asyncPostJson("env", undefined))?.payload.current_dir ?? "offline") + "> ");
          const onTermMounted = async (e) => {
            console.log('onTermMounted');
            await customPrompt(); /* 自分でprompt必要 */
          }
          pty.onSubmit(async (e)=> {
            console.log("submit", e)
            isBusy.value = true;
            await pty.asyncCmd(e);
            await customPrompt(); /* 自分でprompt必要 */
            isBusy.value = false;
          });
          /*
            const onSubmit = async (e) => { }
            だとtermがないときにコマンドの行き先がなくなる
            termRef.valueで分岐させるのも煩雑だしlogが残らなくなるのでいまいち
          */

          /******** key event / shortcut ********/
          // filter(n => n.code.startsWith('Key') && (n.altKey || n.ctrlKey || n.shiftKey) )
          const keydown$ = fromEvent(document, 'keydown').pipe(filter( n => n.repeat === false ));
          keydown$.pipe(filter(n => 
            n.key.startsWith('Arrow') || ['\\', '.'].includes(n.key)
            || (!["Shift", "Control", "Alt"].includes(n.key) && (n.altKey || n.ctrlKey || n.shiftKey))
          )).subscribe( async e => {
            const keys = `${e.shiftKey ? 'shift+' : ''}${e.ctrlKey? 'ctrl+' : ''}${e.altKey? 'alt+' : ''}${e.code}`;
            switch(keys){
              case "shift+ctrl+BracketLeft": { termShow.value = !termShow.value; }break;
              case "shift+ctrl+KeyZ": { pty.input("welcome", 'execute'); } break;
              case "shift+ctrl+KeyA": { pty.log("testwrite\r\n"); } break;
              case "shift+ctrl+KeyX": { pty.hideprompt(); } break;
              case "shift+ctrl+KeyC": { pty.showprompt(); } break;
              
              // コマンド送信テスト
              // case "shift+ctrl+KeyA": { pty.log("testwrite\r\n"); } break;
              // case "shift+ctrl+KeyX": { pty.hideprompt(); } break;
              // case "shift+ctrl+KeyC": { pty.showprompt(); } break;

              default: {} return;
            }
            e.preventDefault();
          });

          /******** drag and dorp ********/

          ( wv 
            ? from(onDrop).pipe( switchMap( e => merge( of(e).pipe(delay(100)), fromEvent(wv, 'newWindowReq')).pipe(first()) ))
            : from(onDrop).pipe( tap(e => { e.stopPropagation(); e.preventDefault(); }) )
          ).subscribe( async e => {
            const mode = "append";
            const commamd = (n) => pty.input(`echo JSON.stringify(${n}))`, mode);
            switch(`${ e.constructor.name }:${ e?.detail?.type ?? e.dataTransfer.items[0].kind }`){
              case 'DragEvent:string': {
                const url = await (()=> new Promise(resolve => e.dataTransfer.items[0].getAsString(data => resolve(data))))();
                commamd(url)
              } break;
              case 'DragEvent:file': { commamd(e.dataTransfer.items[0].getAsFile().name) } break; // cannot read full path
              case 'CustomEvent:file': { commamd(e?.detail?.payload) } break;
              case 'CustomEvent:http': { commamd(e?.detail?.payload) } break;
              default: console.error("unknown type in drop event"); break;
            }
          });

          /******** other event ********/

          if(wv){

            fromEvent(wv, 'write').subscribe((e) => { pty.log(`${e.detail}`); });
            fromEvent(wv, 'prompt').subscribe(async () => { await customPrompt(); });

            const updated$ = fromEvent(wv, 'updated');
            updated$.subscribe(async (e) => { console.log('updated', e); });

            const namedPipe$ = fromEvent(wv, 'namedPipe');
            namedPipe$.subscribe(e => { 
              console.log("namedPipe", e) 
              pty.input(e, 'execute');
            });
          }
          
          /******** onMounted ********/
          onMounted(async () => {
            console.log('app mounted')
            termShow.value = true;
            isBusy.value = false;
            nextTick(() => { console.log('app rendered'); });
          });
          return { 
            isBusy, termShow,
            termRef, onTermMounted, pty, onDrop
          }
        }
      });

      app.component('vue-pane', Pane);
      app.component('vue-split-pane', Splitpanes);
      app.component('my-terminal', wtermComponent);
      app.mount('#app');
    </script>
  </body>
</html>
